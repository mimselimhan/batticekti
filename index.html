<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>√áEKTƒ∞ BATTI - Space Edition</title>
    <style>
        :root {
            --bg-dark: #1a1a1a;
            --bg-panel: #2d2d2d;
            --text-main: #e0e0e0;
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: radial-gradient(circle at center, #2b2b2b 0%, #111111 100%);
            color: var(--text-main);
            font-family: var(--font-main);
            overflow: hidden;
            height: 100vh;
            /* Mobile browser fix for 100vh */
            height: 100dvh; 
            display: flex;
            flex-direction: column;
            perspective: 1000px;
        }

        /* --- ORTAK UI --- */
        button {
            font-family: inherit;
            cursor: pointer;
            outline: none;
        }

        .hidden {
            display: none !important;
        }

        /* --- EFEKTLER VE KATMANLAR --- */
        #fx-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 900;
            opacity: 0;
            transition: opacity 0.1s;
        }
        
        .flash-white { background-color: white; animation: flashAnim 0.2s ease-out forwards; }
        .flash-red { background-color: rgba(255, 51, 51, 0.5); animation: flashAnim 0.3s ease-out forwards; }
        .flash-gold { background-color: rgba(255, 215, 0, 0.3); animation: flashAnim 0.5s ease-out forwards; }
        
        /* ≈ûƒ∞M≈ûEK EFEKTƒ∞ */
        .flash-storm {
            background-color: #fff;
            animation: stormAnim 0.8s linear forwards;
        }

        @keyframes stormAnim {
            0% { opacity: 0; }
            10% { opacity: 0.8; background-color: #fff; }
            20% { opacity: 0; }
            30% { opacity: 0.6; background-color: #ffff00; }
            40% { opacity: 0; }
            60% { opacity: 0.9; background-color: #fff; }
            100% { opacity: 0; }
        }

        @keyframes flashAnim {
            0% { opacity: 0.8; }
            100% { opacity: 0; }
        }

        .shake-hard { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }

        @keyframes shake {
            10%, 90% { transform: translate3d(-4px, 0, 0) rotate(-1deg); }
            20%, 80% { transform: translate3d(6px, 0, 0) rotate(2deg); }
            30%, 50%, 70% { transform: translate3d(-8px, 0, 0) rotate(-2deg); }
            40%, 60% { transform: translate3d(8px, 0, 0) rotate(1deg); }
        }

        /* --- MEN√úLER (LOBBY, PAUSE, END) --- */
        #lobby-screen, #pause-screen, #end-screen, #target-selection-modal, #rules-modal, #duel-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            background: rgba(20, 20, 20, 0.98);
            backdrop-filter: blur(10px);
            padding: 20px;
            overflow-y: auto;
        }

        /* D√úELLO MODALI */
        #duel-modal {
            z-index: 3000;
            background: rgba(0,0,0,0.95);
        }
        
        .duel-arena {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
            width: 100%;
            max-width: 800px;
        }

        .duel-side {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            flex: 1;
        }

        .duel-vs {
            font-size: 4rem;
            font-weight: 900;
            color: #ffff00;
            text-shadow: 0 0 20px #ffff00;
            animation: pulseVs 0.5s infinite alternate;
        }
        @keyframes pulseVs { from { transform: scale(1); } to { transform: scale(1.2); } }

        .dice-box {
            width: 100px;
            height: 100px;
            background: #333;
            border: 4px solid #555;
            border-radius: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3rem;
            font-weight: bold;
            margin: 20px 0;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
        
        .dice-rolling {
            animation: rollAnim 0.1s infinite;
            color: #aaa;
        }
        .dice-winner {
            border-color: #00ff00;
            color: #00ff00;
            box-shadow: 0 0 30px #00ff00;
            transform: scale(1.2);
        }
        .dice-loser {
            border-color: #ff0000;
            color: #ff0000;
            opacity: 0.6;
        }

        @keyframes rollAnim {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(10deg); }
            75% { transform: rotate(-10deg); }
            100% { transform: rotate(0deg); }
        }

        .duel-result-text {
            font-size: 1.5rem;
            font-weight: bold;
            margin-top: 30px;
            color: #fff;
            text-align: center;
            min-height: 40px;
        }

        /* KURALLAR MODALI */
        #rules-modal {
            z-index: 2500;
            justify-content: flex-start;
            padding-top: 40px;
        }

        .rules-container {
            width: 100%;
            max-width: 800px;
            background: #222;
            border: 1px solid #444;
            border-radius: 15px;
            padding: 20px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        }

        .rules-section { margin-bottom: 30px; }
        .rules-section h3 { color: #00ffff; border-bottom: 1px solid #444; padding-bottom: 5px; margin-bottom: 10px; text-transform: uppercase; }
        .rules-section p { font-size: 0.95rem; line-height: 1.5; color: #ccc; margin-bottom: 10px; }
        .rules-section ul { margin-left: 20px; margin-bottom: 10px; color: #bbb; }
        .rules-section li { margin-bottom: 5px; }

        .card-legend-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .card-legend-item {
            background: #333;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        .legend-icon { font-size: 2rem; margin-bottom: 5px; }
        .legend-title { font-weight: bold; font-size: 0.9rem; margin-bottom: 2px; color: #fff; }
        .legend-desc { font-size: 0.75rem; color: #aaa; }

        /* HEDEF SE√áƒ∞M MODALI */
        #target-selection-modal {
            z-index: 2000; /* En √ºstte */
            background: rgba(0, 0, 0, 0.9);
        }

        .target-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-top: 20px;
        }
        
        .target-btn {
            background: #333;
            border: 2px solid #555;
            color: white;
            padding: 20px;
            border-radius: 15px;
            font-size: 1.2rem;
            font-weight: bold;
            transition: transform 0.2s;
        }
        .target-btn:hover {
            transform: scale(1.1);
            border-color: #fff;
        }

        .card-preview-info {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 10px;
            padding: 20px;
            border-radius: 10px;
            background: #222;
            border: 2px solid #fff;
            animation: pulseInfo 1s infinite;
        }
        @keyframes pulseInfo { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* LOBBY STYLES */
        .title-neon {
            font-size: 3rem;
            font-weight: 900;
            text-transform: uppercase;
            color: #fff;
            margin-bottom: 2rem;
            text-align: center;
            text-shadow: 0 0 20px rgba(255,255,255,0.5);
        }

        .lobby-controls {
            background: var(--bg-panel);
            padding: 30px;
            border-radius: 20px;
            border: 1px solid #444;
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .row-group {
            display: flex;
            gap: 15px;
        }
        .row-group > div { flex: 1; }

        label {
            color: #aaa;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 1px;
        }

        select, input[type="text"] {
            padding: 12px;
            background: #1a1a1a;
            border: 2px solid #444;
            border-radius: 8px;
            color: white;
            font-size: 1rem;
            width: 100%;
            outline: none;
            transition: border-color 0.3s;
        }

        select:focus, input[type="text"]:focus {
            border-color: #fff;
        }

        #player-names-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 250px;
            overflow-y: auto;
            padding-right: 5px;
        }

        .btn-neon {
            padding: 15px;
            font-size: 1.2rem;
            font-weight: bold;
            color: #1a1a1a;
            background: #00ff00;
            border: none;
            border-radius: 50px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            transition: all 0.2s ease;
            text-transform: uppercase;
            margin-top: 10px;
        }

        .btn-neon:hover {
            transform: scale(1.05);
            background: #66ff66;
        }
        
        .btn-info {
            background: #3b82f6;
            color: white;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
            font-size: 1rem;
            padding: 12px;
        }
        .btn-info:hover { background: #60a5fa; }

        .btn-resume {
            background: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        .btn-resume:hover { background: #ccffff; }
        
        .btn-restart {
            background: #ff3333;
            color: white;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
        }
        .btn-restart:hover { background: #ff6666; }

        /* --- OYUN ALANI --- */
        #game-screen {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 10;
        }

        /* Header Bar */
        .game-header {
            height: 60px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid #333;
            z-index: 200; /* Header always top */
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.9rem;
            border-radius: 6px;
            border: 1px solid #555;
            background: #333;
            color: #eee;
            font-weight: bold;
        }
        .btn-small:hover { background: #444; }
        
        .btn-danger {
            border-color: #ff3333;
            color: #ff3333;
            background: rgba(255, 51, 51, 0.1);
        }
        .btn-danger:hover { background: rgba(255, 51, 51, 0.3); }

        /* Oyuncu Grid / Flex Layout Update */
        .players-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center; /* Varsayƒ±lan: Ortala */
            align-items: center;
            gap: 12px;
            padding: 10px;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            flex: 1;
            z-index: 20; 
            position: relative;
        }

        /* 4 Ki≈üilik Mod i√ßin Kenarlara Yaslama (K√∂≈üeler) */
        .players-area.mode-4p {
            justify-content: space-between; /* Kenarlara yasla */
        }

        .player-card {
            background: var(--bg-panel);
            border-radius: 16px;
            border: 3px solid #444;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 12px;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            min-height: 130px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
            z-index: 1;
            
            /* Flex sizing logic */
            flex: 1 1 140px; 
            max-width: 200px; /* √áok geni≈ülemesin */
            min-width: 120px;
        }

        .player-card.active {
            transform: scale(1.05);
            border-color: transparent !important;
            z-index: 25;
            background: var(--bg-panel);
        }

        /* --- NEON LOOP EFFECT --- */
        .active-border-glow {
            position: absolute;
            inset: -4px;
            border-radius: 20px; /* Slightly larger than card 16px */
            overflow: hidden;
            z-index: -1;
            pointer-events: none;
        }

        .active-border-glow::before {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            width: 200%; 
            aspect-ratio: 1;
            background: conic-gradient(transparent 0deg, transparent 280deg, var(--player-color) 360deg);
            transform: translate(-50%, -50%);
            animation: borderSpin 2s linear infinite;
        }
        
        @keyframes borderSpin {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* Static glow behind everything */
        .player-card.active::after {
            content: "";
            position: absolute;
            inset: 5px;
            box-shadow: 0 0 25px var(--player-color);
            z-index: -2;
            opacity: 0.8;
        }
        
        .player-name {
            font-weight: bold;
            font-size: 1rem;
            color: #fff;
            margin-bottom: 4px;
            text-align: center;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 2px 8px;
            border-radius: 4px;
            background: rgba(0,0,0,0.4);
        }
        
        .player-stats-row {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 0 5px;
            font-size: 0.8rem;
            margin-bottom: 2px;
        }
        .stat-duel { color: #ffff00; font-weight: bold; }
        .player-buff-indicator { color: #ff00ff; font-weight: bold; }

        .player-score {
            font-size: 2.2rem;
            font-weight: 900;
            color: #fff; /* Rengi JS ile oyuncu rengi olacak */
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            transition: transform 0.2s;
            margin: 4px 0;
            position: relative;
        }

        /* VALUE PROJECTILE ANIMATION (New) */
        .value-projectile {
            position: fixed;
            font-size: 3.5rem;
            font-weight: 900;
            z-index: 2000; /* En √ºstte */
            pointer-events: none;
            transition: all 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
            text-shadow: 0 0 10px #000, 0 0 20px #000;
            opacity: 1;
            transform: translate(-50%, -50%);
        }
        
        .player-score.pop { transform: scale(1.4); }
        .player-score.shrink { color: #ff3333; transform: scale(0.8); }

        .last-action {
            font-size: 0.8rem;
            color: #ccc;
            height: 20px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%;
            margin-bottom: 8px;
        }

        /* JOKER BUTTONS */
        .joker-container {
            display: flex;
            gap: 8px;
            margin-top: auto;
            width: 100%;
            justify-content: center;
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .joker-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid;
            background: #222;
            color: white;
            font-size: 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s;
            position: relative;
        }

        .joker-btn:disabled {
            opacity: 0.3;
            filter: grayscale(100%);
            cursor: not-allowed;
            border-color: #555 !important;
            box-shadow: none !important;
            background: transparent !important;
        }

        /* Renkler statik */
        .joker-pass { border-color: #d946ef; color: #d946ef; }
        .joker-pass:not(:disabled):hover { background: #d946ef; color: white; }

        .joker-drain { border-color: #ef4444; color: #ef4444; }
        .joker-drain:not(:disabled):hover { background: #ef4444; color: white; }

        .joker-double { border-color: #fbbf24; color: #fbbf24; }
        .joker-double:not(:disabled):hover { background: #fbbf24; color: white; }

        .joker-tooltip {
            position: absolute;
            bottom: 110%;
            left: 50%;
            transform: translateX(-50%);
            background: #222;
            font-size: 0.7rem;
            padding: 4px 8px;
            border-radius: 4px;
            opacity: 0;
            pointer-events: none;
            white-space: nowrap;
            transition: opacity 0.2s;
            z-index: 50;
            border: 1px solid #444;
        }
        .joker-btn:hover .joker-tooltip { opacity: 1; }


        /* Orta Alan (Desteler) */
        .center-area {
            flex: 0 0 230px;
            display: flex;
            flex-direction: row; /* Yan yana */
            justify-content: center;
            align-items: center;
            gap: 80px; /* Aralarƒ± a√ßƒ±ldƒ±: 40px -> 80px */
            margin: 30px 0; 
            perspective: 1000px;
            z-index: 500; /* EN √ñNEMLƒ∞: Oyuncu kartlarƒ±nƒ±n √ºst√ºnde */
            position: relative;
        }

        .deck-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .deck-wrapper {
            position: relative;
            width: 110px;
            height: 160px;
            cursor: pointer;
            transition: transform 0.1s, filter 0.3s;
            transform-style: preserve-3d;
        }
        
        .deck-wrapper.disabled {
            filter: grayscale(1) opacity(0.3);
            cursor: not-allowed;
            pointer-events: none;
        }
        
        .deck-wrapper.used {
            filter: opacity(0.6);
            cursor: default;
            /* Used this turn: not grayscale, just dim */
        }

        /* ANA DESTE (MAVƒ∞) */
        .deck-main.deck-active { animation: deckPulseBlue 2s infinite; }
        .deck-main.deck-active::before,
        .deck-main.deck-active::after {
            border: 2px solid #00ffff;
            box-shadow: 0 0 15px #00ffff;
        }

        /* RISK DESTESƒ∞ (KIRMIZI) */
        .deck-attack.deck-active { animation: deckPulseRed 2s infinite; }
        .deck-attack.deck-active::before,
        .deck-attack.deck-active::after {
            border: 2px solid #ff0000;
            box-shadow: 0 0 15px #ff0000;
        }

        /* SALDIRI (D√úELLO) DESTESƒ∞ (SARI) */
        .deck-duel.deck-active { animation: deckPulseYellow 2s infinite; }
        .deck-duel.deck-active::before,
        .deck-duel.deck-active::after {
            border: 2px solid #ffff00;
            box-shadow: 0 0 15px #ffff00;
        }

        /* ORTAK DALGA CSS */
        .deck-active::before,
        .deck-active::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            border-radius: 16px;
            opacity: 0;
            z-index: -1; 
            pointer-events: none;
        }

        .deck-active::before {
            animation: deckWave 2s infinite cubic-bezier(0, 0.2, 0.8, 1);
        }

        .deck-active::after {
            animation: deckWave 2s infinite cubic-bezier(0, 0.2, 0.8, 1);
            animation-delay: 0.8s;
        }

        @keyframes deckPulseBlue {
            0% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.6); transform: scale(1); }
            50% { box-shadow: 0 0 40px rgba(0, 255, 255, 1); transform: scale(1.05); }
            100% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.6); transform: scale(1); }
        }

        @keyframes deckPulseRed {
            0% { box-shadow: 0 0 20px rgba(255, 0, 0, 0.6); transform: scale(1); }
            50% { box-shadow: 0 0 40px rgba(255, 0, 0, 1); transform: scale(1.05); }
            100% { box-shadow: 0 0 20px rgba(255, 0, 0, 0.6); transform: scale(1); }
        }
        
        @keyframes deckPulseYellow {
            0% { box-shadow: 0 0 20px rgba(255, 255, 0, 0.6); transform: scale(1); }
            50% { box-shadow: 0 0 40px rgba(255, 255, 0, 1); transform: scale(1.05); }
            100% { box-shadow: 0 0 20px rgba(255, 255, 0, 0.6); transform: scale(1); }
        }

        @keyframes deckWave {
            0% { transform: scale(1); opacity: 0.9; border-width: 5px; }
            100% { transform: scale(2.5); opacity: 0; border-width: 0px; }
        }

        .deck-wrapper:not(.disabled):active { transform: scale(0.95); }

        .card {
            width: 100%;
            height: 100%;
            border-radius: 12px;
            position: absolute;
            top: 0;
            left: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            text-align: center;
            backface-visibility: hidden;
            background-color: #1e293b;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        .card-back-main {
            background: repeating-linear-gradient(45deg, #0f172a, #0f172a 10px, #1e293b 10px, #1e293b 20px);
            border: 2px solid #00ffff;
        }
        .card-back-main::after { content: "üöÄ"; font-size: 3rem; }

        .card-back-attack {
            background: repeating-linear-gradient(45deg, #2a0f0f, #2a0f0f 10px, #3b1e1e 10px, #3b1e1e 20px);
            border: 2px solid #ff0000;
        }
        .card-back-attack::after { content: "üí£"; font-size: 3rem; }
        
        .card-back-duel {
            background: repeating-linear-gradient(45deg, #333300, #333300 10px, #4d4d00 10px, #4d4d00 20px);
            border: 2px solid #ffff00;
        }
        .card-back-duel::after { content: "‚öîÔ∏è"; font-size: 3rem; color: #ffff00; text-shadow: 0 0 10px #ffff00; }

        .deck-info {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #94a3b8;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }

        .btn-next-turn {
            position: absolute;
            bottom: -60px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 30px;
            font-size: 1rem;
            font-weight: bold;
            color: #000;
            background: #00ffff;
            border: none;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,255,255,0.4);
            animation: pulseBtn 1.5s infinite;
            cursor: pointer;
            z-index: 600; /* En √ºstte */
            white-space: nowrap;
        }
        
        @keyframes pulseBtn {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
            100% { transform: translateX(-50%) scale(1); }
        }

        /* --- U√áAN KART --- */
        .flying-card {
            position: fixed;
            width: 130px;
            height: 180px;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 10px;
            z-index: 1000;
            transform-style: preserve-3d;
            transition: all 0.8s cubic-bezier(0.19, 1, 0.22, 1);
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            background: #1e293b;
            border: 3px solid white;
        }
        
        .card-attack-visual { border-color: #ff0000; color: #ff0000; }
        .card-global-plus { border-color: #00ff88; color: #00ff88; }
        .card-global-minus { border-color: #ff9900; color: #ff9900; }

        .type-number { border-color: #00ffff; color: #00ffff; }
        .type-combo { border-color: #00ff00; color: #00ff00; }
        .type-action { border-color: #ff3333; color: #ff3333; }

        .card-content-icon { font-size: 3.5rem; margin-bottom: 10px; }
        .card-content-text { font-size: 1.2rem; text-transform: uppercase; font-weight: 800; line-height: 1.2; }
        .card-content-desc { font-size: 0.8rem; color: #fff; margin-top: 5px; font-weight: normal; }

        /* --- PAUSE & END SCREEN TABLO --- */
        .scoreboard {
            width: 100%;
            max-width: 600px;
            background: #2d2d2d;
            border-radius: 15px;
            padding: 20px;
            border: 1px solid #444;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            margin-bottom: 30px;
        }

        .score-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid #444;
            font-size: 1.2rem;
            color: #eee;
        }

        .score-row:last-child { border-bottom: none; }
        .score-row:first-child { background: rgba(255, 255, 255, 0.05); font-weight: bold; }
        
        .rank-badge {
            display: inline-flex;
            width: 30px;
            height: 30px;
            justify-content: center;
            align-items: center;
            background: #444;
            border-radius: 50%;
            margin-right: 10px;
            font-size: 0.9rem;
        }

        .end-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            width: 100%;
        }

        /* --- TOAST Bƒ∞LDƒ∞Rƒ∞M --- */
        #toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: #222;
            border: 1px solid #555;
            padding: 15px 30px;
            border-radius: 30px;
            color: white;
            font-size: 1.1rem;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
            z-index: 999;
            white-space: nowrap;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        }

        canvas { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 190; }

        /* Responsive for Mobile */
        @media (max-width: 768px) {
            .title-neon { font-size: 1.8rem; margin-bottom: 1rem; }
            
            /* Shrink Header */
            .game-header { height: 40px; padding: 0 10px; }
            .btn-small { padding: 4px 10px; font-size: 0.75rem; }

            /* Mobile Layout for Players - Use Flex logic */
            .players-area {
                gap: 6px;
                padding: 5px;
            }

            /* Shrink Card Size - REDUCED HEIGHT */
            .player-card {
                min-height: 82px;
                padding: 4px;
                border-radius: 8px;
                border-width: 2px;
                flex: 1 1 28%; /* Try to fit 3, else wrap */
                min-width: 90px;
                max-width: none;
            }
            
            /* Shrink Fonts inside card */
            .player-name { font-size: 0.65rem; margin-bottom: 1px; padding: 1px 4px; }
            .player-score { font-size: 1.4rem; margin: 0; }
            .player-stats-row { font-size: 0.6rem; margin-bottom: 1px; }
            .last-action { font-size: 0.6rem; height: 14px; margin-bottom: 1px; }
            .player-buff-indicator { font-size: 0.6rem !important; }

            /* Shrink Joker Buttons */
            .joker-container { gap: 4px; padding-top: 2px; margin-top: 2px; }
            .joker-btn { width: 22px; height: 22px; font-size: 0.7rem; border-width: 1px; }

            /* Compact Deck Area with SPACE AT BOTTOM for button */
            .center-area {
                flex: 0 0 110px; /* Reduce height from 230px */
                gap: 20px;
                margin: 5px 0 45px 0; /* Added 45px bottom margin to prevent overlap */
            }

            /* Smaller Decks */
            .deck-wrapper { width: 60px; height: 85px; border-radius: 8px; }
            .card { border-radius: 8px; }
            .card-back-main::after, .card-back-attack::after, .card-back-duel::after { font-size: 1.5rem; }
            .deck-info { font-size: 0.65rem; margin-top: 4px; }
            
            /* Button move up */
            .btn-next-turn {
                bottom: -40px; /* Move closer to decks */
                padding: 8px 20px;
                font-size: 0.9rem;
            }

            /* Smaller Flying Card */
            .flying-card {
                width: 90px;
                height: 120px;
                padding: 5px;
            }
            .card-content-icon { font-size: 2rem; margin-bottom: 5px; }
            .card-content-text { font-size: 0.9rem; }
            .card-content-desc { font-size: 0.6rem; }

            /* Smaller Modals */
            .duel-arena { gap: 10px; }
            .duel-vs { font-size: 2rem; }
            .dice-box { width: 60px; height: 60px; font-size: 1.5rem; }
        }

        /* Extra small screens */
        @media (max-width: 380px) {
            .player-card { min-height: 80px; flex-basis: 45%; } /* Go 2 per row on tiny screens */
        }
    </style>
</head>
<body>

    <!-- SES & EFEKTLER -->
    <div id="fx-overlay"></div>
    <canvas id="confetti-canvas"></canvas>
    <div id="toast"></div>

    <!-- KURALLAR MODALI -->
    <section id="rules-modal" class="hidden">
        <div class="rules-container">
            <h2 style="text-align:center; color:white; margin-bottom:20px; text-transform:uppercase; letter-spacing:2px;">Oyun Rehberi</h2>
            
            <div class="rules-section">
                <h3>üéØ Nasƒ±l Oynanƒ±r?</h3>
                <p><strong>Ama√ß:</strong> Hamle destesi bittiƒüinde en y√ºksek puana sahip olmak.</p>
                
                <p><strong>Oyun Akƒ±≈üƒ±:</strong></p>
                <ul>
                    <li>Sƒ±rasƒ± gelen oyuncu ortadaki <strong>HAMLE (Mavi)</strong> destesinden kart √ßeker.</li>
                    <li>Kartƒ±n puanƒ± veya etkisi anƒ±nda i≈ülenir.</li>
                    <li>Eƒüer <strong>Kombo (Ye≈üil)</strong> kartƒ± gelirse (+1 veya +2), oyuncu tekrar kart √ßeker.</li>
                    <li>Aksi takdirde sƒ±ra sonraki oyuncuya ge√ßer.</li>
                </ul>
                
                <p style="margin-top:15px;"><strong>üî• EKSTRA G√ú√áLER (Sƒ±ra Bendeyken):</strong></p>
                <ul>
                    <li><strong style="color:#ff3333">RISK (Kƒ±rmƒ±zƒ± Deste):</strong> √áektiƒüin +/- puanƒ± se√ßtiƒüin bir rakibe uygularsƒ±nƒ±z. (Sƒ±nƒ±rlƒ± Hak).</li>
                    <li><strong style="color:#ffff00">SALDIRI (Sarƒ± Deste):</strong> Bir rakip se√ßip Zar D√ºellosu ba≈ülatƒ±rsƒ±nƒ±z. Kazanan, farkƒ±n 4 katƒ± puan √ßalar! (Sƒ±nƒ±rlƒ± Hak).</li>
                </ul>

                <p style="margin-top:15px;"><strong>üÉè JOKERLER (Her biri oyun boyu 1 KERE):</strong></p>
                <ul>
                    <li><strong>‚û°Ô∏è PAS (Maliyet -20):</strong> √áektiƒüin k√∂t√º kartƒ± bir sonraki oyuncuya kitlersin.</li>
                    <li><strong>üîª YIKIM:</strong> Senden ba≈üka herkese -10 puan verir. Lideri yakalamak i√ßin birebir!</li>
                    <li><strong>‚ö° G√ú√á (3 Tur):</strong> Sonraki 3 tur boyunca kazandƒ±ƒüƒ±n t√ºm sayƒ± puanlarƒ± 2 ile √ßarpƒ±lƒ±r.</li>
                </ul>
            </div>

            <div class="rules-section">
                <h3>üìö Kart Galerisi</h3>
                <div class="card-legend-grid">
                    <!-- Puanlar -->
                    <div class="card-legend-item" style="border-color: #00ffff;">
                        <div class="legend-icon" style="color:#00ffff">#</div>
                        <div class="legend-title">Sayƒ±lar</div>
                        <div class="legend-desc">1-10 Puan kazandƒ±rƒ±r.</div>
                    </div>
                    
                    <!-- Kombolar -->
                    <div class="card-legend-item" style="border-color: #00ff00;">
                        <div class="legend-icon">‚ú®</div>
                        <div class="legend-title">≈ûans / Zar</div>
                        <div class="legend-desc">Ekstra kart √ßektirir (+1 veya +2).</div>
                    </div>

                    <!-- Global -->
                    <div class="card-legend-item" style="border-color: #ff9900;">
                        <div class="legend-icon">üåßÔ∏è / üå™Ô∏è</div>
                        <div class="legend-title">Doƒüa Olaylarƒ±</div>
                        <div class="legend-desc">Yaƒümur (+10) veya Kasƒ±rga (-10) herkese i≈üler.</div>
                    </div>

                    <!-- Hƒ±rsƒ±z -->
                    <div class="card-legend-item" style="border-color: #ff3333;">
                        <div class="legend-icon">üïµÔ∏è</div>
                        <div class="legend-title">Hƒ±rsƒ±z</div>
                        <div class="legend-desc">Liderden puan √ßalar.</div>
                    </div>

                    <!-- ƒ∞flas -->
                    <div class="card-legend-item" style="border-color: #ff3333;">
                        <div class="legend-icon">üìâ</div>
                        <div class="legend-title">ƒ∞flas</div>
                        <div class="legend-desc">Puanƒ±n anƒ±nda yarƒ±ya iner!</div>
                    </div>

                    <!-- Bum -->
                    <div class="card-legend-item" style="border-color: #ff3333;">
                        <div class="legend-icon">üí£</div>
                        <div class="legend-title">BUM!</div>
                        <div class="legend-desc">Sƒ±rayƒ± zorla sonrakine ge√ßirir ve ona kart √ßektirir.</div>
                    </div>
                </div>
            </div>

            <button class="btn-neon" onclick="toggleRules()" style="margin-top:20px; width:100%;">TAMAMDIR</button>
        </div>
    </section>

    <!-- LOBBY SCREEN -->
    <section id="lobby-screen">
        <h1 class="title-neon">√áEKTƒ∞ BATTI</h1>
        <div class="lobby-controls">
            
            <div class="row-group">
                <div class="control-group">
                    <label for="player-count">Oyuncu Sayƒ±sƒ±</label>
                    <select id="player-count" onchange="updateNameInputs()">
                        <option value="2">2 Oyuncu</option>
                        <option value="3">3 Oyuncu</option>
                        <option value="4" selected>4 Oyuncu</option>
                        <option value="5">5 Oyuncu</option>
                        <option value="6">6 Oyuncu</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="deck-size">Kart Sayƒ±sƒ±</label>
                    <select id="deck-size">
                        <option value="10">10 Kart (Demo)</option>
                        <option value="25">25 Kart (Hƒ±zlƒ±)</option>
                        <option value="50">50 Kart (Normal)</option>
                        <option value="75">75 Kart (Uzun)</option>
                        <option value="100" selected>100 Kart (Epik)</option>
                    </select>
                </div>
            </div>

            <div id="player-names-container">
                <!-- JS ile doldurulacak -->
            </div>

            <button class="btn-neon" onclick="startGame()">OYUNU BA≈ûLAT</button>
            <button class="btn-neon btn-info" onclick="toggleRules()">NASIL OYNANIR?</button>
        </div>
    </section>

    <!-- HEDEF SE√áƒ∞M MODALI -->
    <section id="target-selection-modal" class="hidden">
        <h2 style="color:white; text-transform: uppercase; margin-bottom: 20px;">Hedef Se√ß</h2>
        <div id="attack-card-preview" class="card-preview-info">
            <!-- Kart Deƒüeri -->
        </div>
        <div style="color:#aaa; margin-bottom:20px;">Bu eylemi kime uygulamak istersin?</div>
        <div id="target-grid" class="target-grid">
            <!-- Butonlar JS ile gelecek -->
        </div>
        <button class="btn-small btn-danger" onclick="cancelTargetSelection()" style="margin-top:20px">ƒ∞PTAL</button>
    </section>

    <!-- D√úELLO MODALI -->
    <section id="duel-modal" class="hidden">
        <h2 style="color:#ffff00; text-transform: uppercase; margin-bottom: 10px; font-size: 2rem; text-shadow: 0 0 20px yellow;">‚ö° SALDIRI D√úELLOSU ‚ö°</h2>
        <div class="duel-arena">
            <div class="duel-side" id="duel-p1-side">
                <h3 id="duel-p1-name">Oyuncu 1</h3>
                <div class="dice-box" id="duel-dice-1">?</div>
            </div>
            <div class="duel-vs">VS</div>
            <div class="duel-side" id="duel-p2-side">
                <h3 id="duel-p2-name">Oyuncu 2</h3>
                <div class="dice-box" id="duel-dice-2">?</div>
            </div>
        </div>
        <div class="duel-result-text" id="duel-result-text">Zarlar atƒ±lƒ±yor...</div>
    </section>

    <!-- PAUSE SCREEN -->
    <section id="pause-screen" class="hidden">
        <h2 style="color:white; margin-bottom:20px; font-size:2rem;">OYUN DURAKLATILDI</h2>
        <div class="scoreboard" id="pause-scoreboard">
            <!-- Sƒ±ralama buraya gelecek -->
        </div>
        <button class="btn-neon btn-resume" onclick="togglePause()">OYUNA D√ñN</button>
        <button class="btn-neon btn-info" onclick="toggleRules()">KURALLAR</button>
        <button class="btn-neon btn-restart" onclick="returnToLobby()">MEN√úYE D√ñN</button>
    </section>

    <!-- GAME SCREEN -->
    <section id="game-screen" class="hidden">
        <!-- Header Kontrolleri -->
        <div class="game-header">
            <button class="btn-small" onclick="togglePause()">‚è∏ DURAKLAT</button>
            <button class="btn-small btn-danger" onclick="confirmNewGame()">üîÑ YENƒ∞ OYUN</button>
        </div>

        <!-- √úst B√∂l√ºm Oyuncularƒ± -->
        <div class="players-area" id="players-top"></div>

        <!-- Orta B√∂l√ºm (Desteler) -->
        <div class="center-area">
            
            <!-- 1. Risk Destesi (Kƒ±rmƒ±zƒ±) - SOLDA -->
            <div class="deck-container">
                <div class="deck-wrapper deck-attack" id="deck-attack" onclick="onAttackDeckClick()">
                    <div class="card card-back-attack" style="transform: translate(-4px, -4px);"></div>
                    <div class="card card-back-attack" style="transform: translate(-2px, -2px);"></div>
                    <div class="card card-back-attack"></div>
                </div>
                <div class="deck-info" id="attack-deck-count">RISK</div>
            </div>

            <!-- 2. Ana Deste (Mavi) - ORTADA -->
            <div class="deck-container">
                <div class="deck-wrapper deck-main" id="deck" onclick="onDeckClick()">
                    <div class="card card-back-main" style="transform: translate(-4px, -4px);"></div>
                    <div class="card card-back-main" style="transform: translate(-2px, -2px);"></div>
                    <div class="card card-back-main" id="top-card"></div>
                </div>
                <div class="deck-info" id="deck-count">HAMLE</div>
            </div>

            <!-- 3. Saldƒ±rƒ±/D√ºello Destesi (Sarƒ±) - SAƒûDA -->
            <div class="deck-container">
                <div class="deck-wrapper deck-duel" id="deck-duel" onclick="onDuelDeckClick()">
                    <div class="card card-back-duel" style="transform: translate(-4px, -4px);"></div>
                    <div class="card card-back-duel" style="transform: translate(-2px, -2px);"></div>
                    <div class="card card-back-duel"></div>
                </div>
                <div class="deck-info" id="duel-deck-count">SALDIRI</div>
            </div>

            <button id="btn-next-turn" class="btn-next-turn hidden" onclick="manualEndTurn()">SIRAYI DEVRET</button>
        </div>

        <!-- Alt B√∂l√ºm Oyuncularƒ± -->
        <div class="players-area" id="players-bottom"></div>
    </section>

    <!-- END SCREEN -->
    <section id="end-screen" class="hidden">
        <h2 class="title-neon" id="winner-text">KAZANAN: OYUNCU 1</h2>
        
        <div class="scoreboard" id="scoreboard-list">
            <!-- JS ile doldurulacak -->
        </div>

        <div class="end-controls">
            <button class="btn-neon btn-info" onclick="restartSamePlayers()">YENƒ∞ TUR (AYNI EKƒ∞P)</button>
            <button class="btn-neon btn-restart" onclick="returnToLobby()">MEN√úYE D√ñN</button>
        </div>
    </section>

    <script>
        /* --- SES & EFEKTLER --- */
        const AudioEngine = {
            ctx: null,
            init: function() {
                if (!this.ctx) { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); }
                if (this.ctx.state === 'suspended') { this.ctx.resume(); }
            },
            playTone: function(freq, type, duration, startTime = 0) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(this.ctx.currentTime + startTime);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime + startTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + startTime + duration);
                osc.stop(this.ctx.currentTime + startTime + duration);
            },
            playDraw: function() { this.init(); this.playTone(300, 'sine', 0.1); },
            playAttackDraw: function() { this.init(); this.playTone(150, 'sawtooth', 0.2); },
            playScore: function() { this.init(); this.playTone(800, 'sine', 0.1); this.playTone(1200, 'square', 0.1, 0.1); },
            playCombo: function() { this.init(); this.playTone(400, 'triangle', 0.2); this.playTone(600, 'triangle', 0.2, 0.1); },
            playAlarm: function() {
                this.init();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(600, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(800, this.ctx.currentTime + 0.2);
                osc.frequency.linearRampToValueAtTime(600, this.ctx.currentTime + 0.4);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.4);
                gain.gain.value = 0.15;
            },
            playThunder: function() {
                this.init();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth'; // noise daha iyi ama basit osilat√∂r ile sim√ºle
                osc.frequency.setValueAtTime(100, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
                osc.start();
                osc.stop(this.ctx.currentTime + 1);
            },
            playPowerUp: function() {
                this.init();
                this.playTone(400, 'sine', 0.1);
                this.playTone(600, 'sine', 0.1, 0.1);
                this.playTone(1000, 'sine', 0.3, 0.2);
            },
            playActionBad: function(type) {
                this.init();
                if (type === 'THIEF') {
                    this.playTone(200, 'sawtooth', 0.3);
                    this.playTone(150, 'sine', 0.3, 0.1);
                } else if (type === 'BANKRUPT' || type === 'GLOBAL_MINUS') {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(300, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.8);
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    osc.start();
                    gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.8);
                    osc.stop(this.ctx.currentTime + 0.8);
                } else if (type === 'BOOM') {
                    this.playTone(100, 'square', 0.1);
                    this.playTone(50, 'sawtooth', 0.3, 0.05);
                }
            },
            playWin: function() {
                this.init();
                [440, 554, 659, 880].forEach((freq, i) => { this.playTone(freq, 'sine', 0.4, i * 0.2); });
            }
        };

        const VFX = {
            shakeScreen: function() {
                document.body.classList.add('shake-hard');
                setTimeout(() => document.body.classList.remove('shake-hard'), 500);
            },
            flash: function(color) {
                const overlay = document.getElementById('fx-overlay');
                overlay.className = ''; 
                void overlay.offsetWidth;
                if (color === 'white') overlay.classList.add('flash-white');
                else if (color === 'red') overlay.classList.add('flash-red');
                else if (color === 'gold') overlay.classList.add('flash-gold');
                else if (color === 'storm') overlay.classList.add('flash-storm');
            }
        };

        /**
         * SABƒ∞TLER VE KONFƒ∞G
         */
        const CONSTANTS = {
            CARD_TYPES: { NUMBER: 'number', COMBO: 'combo', ACTION: 'action', ATTACK: 'attack', DUEL: 'duel', GLOBAL_PLUS: 'global_plus', GLOBAL_MINUS: 'global_minus' },
            TURN_PHASES: { WAITING_DRAW: 0, POST_DRAW: 1 }
        };

        // Oyuncu Renk Paleti
        const PLAYER_COLORS = [
            '#3b82f6', // Mavi
            '#ef4444', // Kƒ±rmƒ±zƒ±
            '#22c55e', // Ye≈üil
            '#eab308', // Sarƒ±
            '#a855f7', // Mor
            '#f97316'  // Turuncu
        ];

        const ACTIONS = {
            THIEF: { label: 'HIRSIZ', desc: 'Liderden Puan √áal!', icon: 'üïµÔ∏è' },
            BANKRUPT: { label: 'ƒ∞FLAS', desc: 'Puanƒ±n Yarƒ±ya ƒ∞ner!', icon: 'üìâ' },
            BOOM: { label: 'BUM!', desc: 'Sƒ±radaki Zorla √áeker!', icon: 'üí£' }
        };
        
        const GLOBALS = {
            PLUS: { label: 'YAƒûMUR', desc: 'Herkese +10 Puan!', icon: 'üåßÔ∏è' },
            MINUS: { label: 'KASIRGA', desc: 'Herkese -10 Puan!', icon: 'üå™Ô∏è' }
        };

        const COMBOS = {
            DOUBLE: { label: '√áƒ∞FTE ≈ûANS', val: 2, icon: '‚ú®', desc: '+2 Kart √áek' },
            DICE: { label: 'ZAR AT', val: 1, icon: 'üé≤', desc: '+1 Kart √áek' }
        };

        let state = {
            players: [],
            deck: [],
            attackDeck: [], // Risk destesi (Kƒ±rmƒ±zƒ±)
            duelDeck: [], // Saldƒ±rƒ±/D√ºello destesi (Sarƒ±)
            currentPlayerIdx: 0,
            drawsLeft: 1,
            turnPhase: CONSTANTS.TURN_PHASES.WAITING_DRAW,
            isGameOver: false,
            isPaused: false,
            lastDrawnCard: null,
            lastUndoOp: null,
            isProcessing: false,
            pendingAttackCard: null, // Risk veya Duel kartƒ± olabilir
            pendingDuel: false, // D√ºello modu aktif mi
            hasUsedRiskCard: false, // Bu tur risk kartƒ± kullandƒ± mƒ±?
            hasUsedDuelCard: false // Bu tur d√ºello kartƒ± kullandƒ± mƒ±?
        };

        const el = {
            lobby: document.getElementById('lobby-screen'),
            game: document.getElementById('game-screen'),
            end: document.getElementById('end-screen'),
            pause: document.getElementById('pause-screen'),
            targetModal: document.getElementById('target-selection-modal'),
            duelModal: document.getElementById('duel-modal'),
            rulesModal: document.getElementById('rules-modal'),
            nameContainer: document.getElementById('player-names-container'),
            playerCount: document.getElementById('player-count'),
            deckSize: document.getElementById('deck-size'),
            deckCount: document.getElementById('deck-count'),
            attackDeckCount: document.getElementById('attack-deck-count'),
            duelDeckCount: document.getElementById('duel-deck-count'),
            deck: document.getElementById('deck'),
            attackDeck: document.getElementById('deck-attack'),
            duelDeck: document.getElementById('deck-duel'),
            playersTop: document.getElementById('players-top'),
            playersBottom: document.getElementById('players-bottom'),
            scoreboard: document.getElementById('scoreboard-list'),
            pauseScoreboard: document.getElementById('pause-scoreboard'),
            winnerText: document.getElementById('winner-text'),
            toast: document.getElementById('toast'),
            btnNextTurn: document.getElementById('btn-next-turn'),
            targetGrid: document.getElementById('target-grid'),
            attackCardPreview: document.getElementById('attack-card-preview')
        };

        window.onload = () => {
            updateNameInputs();
        };

        function updateNameInputs() {
            const count = parseInt(el.playerCount.value);
            el.nameContainer.innerHTML = '';
            for (let i = 1; i <= count; i++) {
                const div = document.createElement('div');
                div.className = 'control-group';
                div.innerHTML = `
                    <label>Oyuncu ${i}</label>
                    <input type="text" id="pname-${i}" value="Oyuncu ${i}" maxlength="12" style="border-color: ${PLAYER_COLORS[i-1]}">
                `;
                el.nameContainer.appendChild(div);
            }
        }

        /* --- OYUN Y√ñNETƒ∞Mƒ∞ --- */
        
        function startGame() {
            AudioEngine.init();
            const count = parseInt(el.playerCount.value);
            const totalCards = parseInt(el.deckSize.value) || 100;
            
            // HESAPLAMALAR (ƒ∞steklere G√∂re D√ºzeltildi)
            // Risk: Ki≈üi ba≈üƒ± Toplam Kartƒ±n 1/10'u
            const riskPerPlayer = Math.ceil(totalCards / 10);
            
            // Saldƒ±rƒ± (Duel): Ki≈üi ba≈üƒ± Toplam Kartƒ±n 1/20'si
            const duelPerPlayer = Math.ceil(totalCards / 20);

            state.players = [];
            
            for (let i = 1; i <= count; i++) {
                const nameInput = document.getElementById(`pname-${i}`).value.trim() || `Oyuncu ${i}`;
                state.players.push({
                    id: i,
                    name: nameInput,
                    score: 0,
                    color: PLAYER_COLORS[i-1],
                    lastAction: 'Hazƒ±r',
                    jokers: { pass: false, drain: false, double: false },
                    buffs: { doubleDuration: 0 },
                    riskRights: riskPerPlayer, // Dinamik Hak
                    duelRights: duelPerPlayer  // Dinamik Hak
                });
            }

            state.players = shuffle(state.players);

            state.deck = createDeck(totalCards);
            // Toplam risk destesi = ki≈üi ba≈üƒ± hak * oyuncu sayƒ±sƒ±
            state.attackDeck = createAttackDeck(riskPerPlayer * count); 
            // Toplam duel destesi = ki≈üi ba≈üƒ± hak * oyuncu sayƒ±sƒ±
            state.duelDeck = createDuelDeck(duelPerPlayer * count); 
            
            state.currentPlayerIdx = 0;
            state.drawsLeft = 1;
            state.isGameOver = false;
            state.isPaused = false;
            state.turnPhase = CONSTANTS.TURN_PHASES.WAITING_DRAW;
            state.lastDrawnCard = null;
            state.lastUndoOp = null;
            state.isProcessing = false;
            state.pendingAttackCard = null;
            state.pendingDuel = false;
            state.hasUsedRiskCard = false;
            state.hasUsedDuelCard = false;

            el.lobby.classList.add('hidden');
            el.game.classList.remove('hidden');
            el.end.classList.add('hidden');
            el.pause.classList.add('hidden');
            el.targetModal.classList.add('hidden');
            el.duelModal.classList.add('hidden');
            el.rulesModal.classList.add('hidden');
            
            renderBoard();
            updateDeckUI();
            showToast(`${state.players[0].name} Ba≈ülƒ±yor!`);
        }

        // Aynƒ± ekiple yeni tur (Scores reset, decks reset)
        function restartSamePlayers() {
            const count = state.players.length;
            const totalCards = parseInt(el.deckSize.value) || 100;
            
            const riskPerPlayer = Math.ceil(totalCards / 10);
            const duelPerPlayer = Math.ceil(totalCards / 20);
            
            state.players.forEach(p => {
                p.score = 0;
                p.lastAction = 'Hazƒ±r';
                p.jokers = { pass: false, drain: false, double: false };
                p.buffs = { doubleDuration: 0 };
                p.riskRights = riskPerPlayer;
                p.duelRights = duelPerPlayer;
            });
            
            state.players = shuffle(state.players);

            state.deck = createDeck(totalCards);
            state.attackDeck = createAttackDeck(riskPerPlayer * count); 
            state.duelDeck = createDuelDeck(duelPerPlayer * count);
            
            state.currentPlayerIdx = 0;
            state.drawsLeft = 1;
            state.isGameOver = false;
            state.isPaused = false;
            state.turnPhase = CONSTANTS.TURN_PHASES.WAITING_DRAW;
            state.lastDrawnCard = null;
            state.lastUndoOp = null;
            state.isProcessing = false;
            state.pendingAttackCard = null;
            state.pendingDuel = false;
            state.hasUsedRiskCard = false;
            state.hasUsedDuelCard = false;

            stopConfetti();
            el.end.classList.add('hidden');
            el.game.classList.remove('hidden');
            
            renderBoard();
            updateDeckUI();
            showToast(`${state.players[0].name} Ba≈ülƒ±yor!`);
        }

        function confirmNewGame() {
            returnToLobby();
        }

        function togglePause() {
            if (!el.rulesModal.classList.contains('hidden')) {
                el.rulesModal.classList.add('hidden');
                return;
            }

            state.isPaused = !state.isPaused;
            if (state.isPaused) {
                el.game.classList.add('hidden');
                el.pause.classList.remove('hidden');
                renderPauseScoreboard();
            } else {
                el.pause.classList.add('hidden');
                el.game.classList.remove('hidden');
            }
        }

        function toggleRules() {
            el.rulesModal.classList.toggle('hidden');
        }

        function renderPauseScoreboard() {
            const sorted = [...state.players].sort((a, b) => b.score - a.score);
            let html = '';
            sorted.forEach((p, idx) => {
                html += `
                    <div class="score-row">
                        <div style="display:flex; align-items:center;">
                            <span class="rank-badge">${idx + 1}</span>
                            <span style="color:${p.color}; font-weight:bold;">${p.name}</span>
                        </div>
                        <div style="font-weight:bold; color: ${p.color}">${p.score}</div>
                    </div>
                `;
            });
            el.pauseScoreboard.innerHTML = html;
        }

        function createDeck(totalCards) {
            let globalCount = Math.floor(totalCards * 0.1);
            if (globalCount < 2) globalCount = 2;

            let numCount = Math.floor(totalCards * 0.5);
            let comboCount = Math.floor(totalCards * 0.2);
            let actionCount = totalCards - numCount - comboCount - globalCount; 

            let deck = [];
            
            for (let i = 0; i < numCount; i++) {
                const val = Math.floor(Math.random() * 10) + 1;
                deck.push({ type: CONSTANTS.CARD_TYPES.NUMBER, value: val, meta: { label: val.toString(), icon: '#', desc: 'Puan' } });
            }
            for (let i = 0; i < comboCount; i++) {
                const isDouble = Math.random() > 0.5;
                deck.push({ type: CONSTANTS.CARD_TYPES.COMBO, value: 0, meta: isDouble ? COMBOS.DOUBLE : COMBOS.DICE });
            }
            for (let i = 0; i < globalCount; i++) {
                const isPlus = Math.random() > 0.5;
                deck.push({ 
                    type: isPlus ? CONSTANTS.CARD_TYPES.GLOBAL_PLUS : CONSTANTS.CARD_TYPES.GLOBAL_MINUS,
                    value: 0,
                    meta: isPlus ? GLOBALS.PLUS : GLOBALS.MINUS 
                });
            }
            for (let i = 0; i < actionCount; i++) {
                const r = Math.random();
                let key = (r < 0.33) ? 'THIEF' : (r < 0.66 ? 'BANKRUPT' : 'BOOM');
                deck.push({ type: CONSTANTS.CARD_TYPES.ACTION, value: 0, meta: { ...ACTIONS[key], actionKey: key } });
            }
            return shuffle(deck);
        }

        function createAttackDeck(totalCount) {
            let deck = [];
            const values = [5, 10, -5, -10];
            
            for (let i = 0; i < totalCount; i++) {
                const val = values[Math.floor(Math.random() * values.length)];
                deck.push({
                    type: CONSTANTS.CARD_TYPES.ATTACK,
                    value: val,
                    meta: {
                        label: val > 0 ? `+${val}` : `${val}`,
                        icon: 'üí£',
                        desc: 'Hedefe Uygula'
                    }
                });
            }
            return shuffle(deck);
        }

        function createDuelDeck(totalCount) {
            let deck = [];
            for(let i=0; i<totalCount; i++) {
                deck.push({
                    type: CONSTANTS.CARD_TYPES.DUEL,
                    value: 0,
                    meta: {
                        label: "D√úELLO",
                        icon: "‚öîÔ∏è",
                        desc: "Zar Sava≈üƒ±!"
                    }
                });
            }
            return deck;
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        /* --- SKOR ANƒ∞MASYONU YARDIMCILARI --- */
        function animateNumber(obj, start, end, duration) {
            if (start === end) {
                obj.innerText = end;
                return;
            }
            let startTimestamp = null;
            const step = (timestamp) => {
                if (!startTimestamp) startTimestamp = timestamp;
                const progress = Math.min((timestamp - startTimestamp) / duration, 1);
                // easeOutExpo benzeri basit bir easing
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                const current = Math.floor(easeProgress * (end - start) + start);
                obj.innerText = current;
                if (progress < 1) {
                    window.requestAnimationFrame(step);
                } else {
                    obj.innerText = end;
                }
            };
            window.requestAnimationFrame(step);
        }

        // Bu fonksiyon artƒ±k direkt √ßaƒüƒ±rmak yerine "projectile" animasyonundan sonra √ßaƒürƒ±lacak
        function changeScore(player, amount, skipRender = false) {
            const oldScore = player.score;
            player.score += amount;
            
            if(!skipRender) renderBoard();
            
            // Render sonrasƒ± element yenilendiƒüi i√ßin tekrar se√ßiyoruz
            const scoreEl = document.getElementById(`score-${player.id}`);
            if (scoreEl) {
                animateNumber(scoreEl, oldScore, player.score, 1000);
                // K√º√ß√ºk bir "impact" efekti
                scoreEl.classList.remove('pop', 'shrink');
                void scoreEl.offsetWidth;
                if(amount !== 0) scoreEl.classList.add(amount > 0 ? 'pop' : 'shrink');
            }
        }
        
        /* --- NEW PROJECTILE SYSTEM --- */
        function flyValueToScore(startRect, targetPlayerId, value, onComplete) {
            if (!startRect || !value) {
                if(onComplete) onComplete();
                return;
            }
            
            // Create visual element
            const projectile = document.createElement('div');
            projectile.className = 'value-projectile';
            projectile.innerText = value > 0 ? `+${value}` : `${value}`;
            projectile.style.color = value > 0 ? '#00ff00' : '#ff3333';
            
            // Initial Position
            projectile.style.left = (startRect.left + startRect.width/2) + 'px';
            projectile.style.top = (startRect.top + startRect.height/2) + 'px';
            projectile.style.transform = 'translate(-50%, -50%) scale(0.5)';
            
            document.body.appendChild(projectile);
            
            // Target Position
            const targetCard = document.getElementById(`player-card-${targetPlayerId}`);
            const targetScore = document.getElementById(`score-${targetPlayerId}`);
            
            // Eƒüer hedef element bulunamazsa (nadiren)
            if (!targetCard || !targetScore) {
                projectile.remove();
                if(onComplete) onComplete();
                return;
            }
            
            // Force reflow to ensure start position is applied
            void projectile.offsetWidth;
            
            // Animate to target
            const tRect = targetScore.getBoundingClientRect();
            
            requestAnimationFrame(() => {
                projectile.style.left = (tRect.left + tRect.width/2) + 'px';
                projectile.style.top = (tRect.top + tRect.height/2) + 'px';
                projectile.style.transform = 'translate(-50%, -50%) scale(1.2)';
                projectile.style.opacity = '1';
            });
            
            // Clean up
            setTimeout(() => {
                projectile.style.opacity = '0';
                projectile.style.transform = 'translate(-50%, -100%) scale(0.8)'; // Fade up slightly
                setTimeout(() => {
                    projectile.remove();
                    if(onComplete) onComplete();
                }, 100);
            }, 600); // Matches transition time
        }

        // --- ANA DESTE TIKLAMA ---
        let lastDeckClick = 0;
        function onDeckClick() {
            const now = Date.now();
            if (now - lastDeckClick < 600) return; 
            lastDeckClick = now;

            if (state.isGameOver || state.isPaused || state.turnPhase !== CONSTANTS.TURN_PHASES.WAITING_DRAW || state.deck.length === 0) return;
            if (state.isProcessing) return; 
            
            state.isProcessing = true; 
            drawCardLogic();
        }

        function drawCardLogic(forced = false) {
            if (state.deck.length === 0) {
                endGame();
                state.isProcessing = false;
                return;
            }

            if(forced) state.isProcessing = true;

            const card = state.deck.pop();
            state.lastDrawnCard = card;
            
            updateDeckUI();
            renderBoard(); 
            AudioEngine.playDraw();

            const player = state.players[state.currentPlayerIdx];

            // Kart a√ßƒ±lƒ±yor ve callback'e "kartƒ±n son pozisyonu"nu d√∂n√ºyor
            animateDraw(card, state.currentPlayerIdx, (finalCardRect) => {
                applyCardEffect(card, player, finalCardRect);
            });
        }

        // --- RISK (KIRMIZI) DESTESƒ∞ ---
        function onAttackDeckClick() {
            if (state.isGameOver || state.isPaused || state.isProcessing) return;
            
            const player = state.players[state.currentPlayerIdx];
            
            if (state.hasUsedRiskCard) {
                showToast("Her tur sadece 1 Risk kartƒ±!");
                AudioEngine.playActionBad('THIEF'); 
                return;
            }

            if (player.riskRights <= 0) {
                showToast("Risk hakkƒ±n kalmadƒ±!");
                return;
            }

            if (state.attackDeck.length === 0) {
                showToast("Risk destesi bitti!");
                return;
            }

            state.isProcessing = true;
            const card = state.attackDeck.pop();
            player.riskRights--;
            state.hasUsedRiskCard = true;
            state.pendingAttackCard = card;
            state.pendingDuel = false;
            
            updateDeckUI();
            AudioEngine.playAttackDraw();
            showTargetSelection(card);
        }

        // --- SALDIRI/D√úELLO (SARI) DESTESƒ∞ ---
        function onDuelDeckClick() {
            if (state.isGameOver || state.isPaused || state.isProcessing) return;
            
            const player = state.players[state.currentPlayerIdx];
            
            if (state.hasUsedDuelCard) {
                showToast("Her tur sadece 1 Saldƒ±rƒ± yapabilirsin!");
                AudioEngine.playActionBad('THIEF');
                return;
            }

            if (player.duelRights <= 0) {
                showToast("Saldƒ±rƒ± hakkƒ±n kalmadƒ±!");
                return;
            }
            
            if (state.duelDeck.length === 0) {
                showToast("Saldƒ±rƒ± destesi bitti!");
                return;
            }

            // Kartƒ± desteden √ßek (sayacƒ± d√º≈ü√ºr)
            const cardData = state.duelDeck.pop(); 
            
            state.isProcessing = true;
            player.duelRights--;
            state.hasUsedDuelCard = true;
            state.pendingAttackCard = cardData;
            state.pendingDuel = true;

            updateDeckUI();
            AudioEngine.playThunder();
            VFX.flash('storm'); // ≈ûim≈üek √ßaktƒ±r
            
            showTargetSelection(cardData);
        }

        function showTargetSelection(card) {
            el.attackCardPreview.innerText = card.meta.label;
            
            if (state.pendingDuel) {
                el.attackCardPreview.style.color = '#ffff00';
                el.attackCardPreview.style.borderColor = '#ffff00';
            } else {
                el.attackCardPreview.style.color = card.value > 0 ? '#00ff00' : '#ff0000';
                el.attackCardPreview.style.borderColor = card.value > 0 ? '#00ff00' : '#ff0000';
            }
            
            el.targetGrid.innerHTML = '';
            const currentPlayerId = state.players[state.currentPlayerIdx].id;
            const validTargets = state.players.filter(p => p.id !== currentPlayerId);

            validTargets.forEach(p => {
                const btn = document.createElement('button');
                btn.className = 'target-btn';
                btn.innerHTML = `<div>${p.name}</div><div style="font-size:0.8rem">${p.score} Puan</div>`;
                btn.style.borderColor = p.color;
                btn.onclick = () => handleTargetSelection(p.id);
                el.targetGrid.appendChild(btn);
            });

            el.targetModal.classList.remove('hidden');
        }

        function cancelTargetSelection() {
             const player = state.players[state.currentPlayerIdx];
             // ƒ∞ptal edilirse hakkƒ± geri ver (Kullanƒ±cƒ± dostu olmasƒ± i√ßin)
             if (state.pendingDuel) {
                 player.duelRights++;
                 state.duelDeck.push(state.pendingAttackCard); // Kartƒ± geri koy
                 state.hasUsedDuelCard = false;
             } else {
                 player.riskRights++;
                 state.hasUsedRiskCard = false;
                 if(state.pendingAttackCard) state.attackDeck.push(state.pendingAttackCard); // Kartƒ± geri koy
             }
             
             state.pendingAttackCard = null;
             state.pendingDuel = false;
             state.isProcessing = false;
             el.targetModal.classList.add('hidden');
             updateDeckUI();
             renderBoard();
        }

        function handleTargetSelection(targetId) {
            el.targetModal.classList.add('hidden');
            const card = state.pendingAttackCard;
            const targetPlayer = state.players.find(p => p.id === targetId);
            const actor = state.players[state.currentPlayerIdx];

            if (state.pendingDuel) {
                // D√ºello Ba≈ülat
                startDuel(actor, targetPlayer);
            } else {
                // Normal Risk Kartƒ± - Burasƒ± da animasyonlu olsun
                if (targetPlayer && card) {
                    let finalVal = card.value;
                    
                    // Saldƒ±ranƒ±n kartƒ±ndan (veya ortadan) kurbana u√ßsun
                    const deckRect = el.attackDeck.getBoundingClientRect();
                    
                    flyValueToScore(deckRect, targetPlayer.id, finalVal, () => {
                        // Render atlatƒ±lƒ±yor, i≈ülem bitince manuel yapƒ±lacak
                        changeScore(targetPlayer, finalVal, true);
                        if (finalVal > 0) AudioEngine.playScore();
                        else AudioEngine.playActionBad('THIEF');
                        
                        showToast(`${actor.name} -> ${targetPlayer.name}: ${finalVal}`);
                        state.pendingAttackCard = null;
                        
                        // √ñNEMLƒ∞: ƒ∞≈ülem bitti bayraƒüƒ±nƒ± indir ve render et ki ƒ±≈üƒ±klar geri gelsin
                        state.isProcessing = false;
                        renderBoard(); 
                    });
                }
            }
        }

        /* --- D√úELLO MANTIƒûI --- */
        function startDuel(attacker, defender) {
            el.duelModal.classList.remove('hidden');
            
            // ≈ûim≈üek efekti
            VFX.shakeScreen();
            VFX.flash('storm');
            AudioEngine.playThunder();

            document.getElementById('duel-p1-name').innerText = attacker.name;
            document.getElementById('duel-p2-name').innerText = defender.name;
            
            const d1 = document.getElementById('duel-dice-1');
            const d2 = document.getElementById('duel-dice-2');
            const resText = document.getElementById('duel-result-text');
            
            d1.className = 'dice-box dice-rolling';
            d2.className = 'dice-box dice-rolling';
            d1.innerText = '?';
            d2.innerText = '?';
            resText.innerText = "ZARLAR ATILIYOR...";

            // Sim√ºlasyon
            setTimeout(() => {
                const roll1 = Math.floor(Math.random() * 6) + 1;
                const roll2 = Math.floor(Math.random() * 6) + 1;

                d1.className = 'dice-box';
                d2.className = 'dice-box';
                d1.innerText = roll1;
                d2.innerText = roll2;
                
                // Zar elementlerinin yerlerini al, buradan puan u√ßacak
                const d1Rect = d1.getBoundingClientRect();
                const d2Rect = d2.getBoundingClientRect();

                let winner = null;
                let steal = 0;

                if (roll1 > roll2) {
                    winner = attacker;
                    d1.classList.add('dice-winner');
                    d2.classList.add('dice-loser');
                    steal = roll1 * 4;
                    resText.innerText = `${attacker.name} KAZANDI! ${steal} PUAN √áALIYOR!`;
                } else if (roll2 > roll1) {
                    winner = defender;
                    d2.classList.add('dice-winner');
                    d1.classList.add('dice-loser');
                    steal = roll2 * 4;
                    resText.innerText = `${defender.name} KAZANDI! ${steal} PUAN √áALIYOR!`;
                } else {
                    resText.innerText = "BERABERE! PUAN DEƒûƒ∞≈ûƒ∞Mƒ∞ YOK.";
                    AudioEngine.playDraw();
                }
                
                // Sonucun okunmasƒ± i√ßin kƒ±sa bir bekleme
                // √ñNCE MODALI KAPAT, SONRA ANƒ∞MASYONU YAP
                setTimeout(() => {
                    el.duelModal.classList.add('hidden');
                    
                    setTimeout(() => {
                         if (winner === attacker) {
                             // √ñnce kaybeden d√º≈üs√ºn
                            flyValueToScore(d2Rect, defender.id, -steal, () => changeScore(defender, -steal, true));
                            // Sonra kazanan alsƒ±n
                            setTimeout(() => {
                                flyValueToScore(d1Rect, attacker.id, steal, () => {
                                    changeScore(attacker, steal, true);
                                    AudioEngine.playWin();
                                    
                                    state.isProcessing = false;
                                    state.pendingAttackCard = null;
                                    state.pendingDuel = false;
                                    renderBoard();
                                });
                            }, 500);
                            showToast(`${attacker.name} ${steal} puan √ßaldƒ±!`);
                        } else if (winner === defender) {
                             flyValueToScore(d1Rect, attacker.id, -steal, () => changeScore(attacker, -steal, true));
                            setTimeout(() => {
                                flyValueToScore(d2Rect, defender.id, steal, () => {
                                    changeScore(defender, steal, true);
                                    AudioEngine.playActionBad('BOOM');
                                    
                                    state.isProcessing = false;
                                    state.pendingAttackCard = null;
                                    state.pendingDuel = false;
                                    renderBoard();
                                });
                            }, 500);
                            showToast(`${defender.name} ${steal} puan √ßaldƒ±!`);
                        } else {
                            // Berabere
                            state.isProcessing = false;
                            state.pendingAttackCard = null;
                            state.pendingDuel = false;
                            renderBoard();
                        }

                    }, 100); // Modal kapandƒ±ktan √ßok kƒ±sa bir s√ºre sonra ba≈ülat

                }, 1500); // 1.5 saniye sonucu oku

            }, 1500);
        }

        // Modified to accept visual start position
        function applyCardEffect(card, player, visualRect) {
            state.lastUndoOp = null; 
            let log = "";
            
            // Default center if visualRect is missing
            if(!visualRect) visualRect = el.deck.getBoundingClientRect();

            const afterEffect = () => {
                 if (state.deck.length === 0) {
                    showToast("DESTE Bƒ∞TTƒ∞! OYUN SONA ERDƒ∞!");
                    setTimeout(endGame, 1500);
                    return;
                }

                if (state.drawsLeft > 1) {
                    state.drawsLeft--;
                    state.turnPhase = CONSTANTS.TURN_PHASES.WAITING_DRAW;
                    showToast(`${player.name} tekrar √ßekiyor!`);
                } else {
                    state.turnPhase = CONSTANTS.TURN_PHASES.POST_DRAW;
                    state.drawsLeft = 0;
                    showToast("Sƒ±rayƒ± Devret veya Aksiyon Al.");
                }
                state.isProcessing = false; 
                renderBoard();
            };

            if (card.type === CONSTANTS.CARD_TYPES.NUMBER) {
                let points = card.value;
                if (player.buffs.doubleDuration > 0) {
                    points *= 2;
                    player.buffs.doubleDuration--;
                    log = `‚ö° 2x Aktif! +${points}`;
                } else {
                    log = `+${points} Puan`;
                }
                
                // ANIMATION: Fly Value -> Score
                flyValueToScore(visualRect, player.id, points, () => {
                    changeScore(player, points);
                    AudioEngine.playScore();
                    afterEffect();
                });
                
                const pts = points;
                state.lastUndoOp = () => { changeScore(player, -pts); };
            }
            else if (card.type === CONSTANTS.CARD_TYPES.COMBO) {
                const extra = card.meta.val;
                state.drawsLeft += extra;
                log = `${extra} Kart Daha!`;
                AudioEngine.playCombo();
                // No score change animation, just text
                afterEffect();
                state.lastUndoOp = () => { state.drawsLeft -= extra; };
            }
            else if (card.type === CONSTANTS.CARD_TYPES.GLOBAL_PLUS) {
                AudioEngine.playPowerUp();
                VFX.flash('gold');
                
                // Everyone gets +10, fly from center
                const centerRect = el.deck.getBoundingClientRect();
                let completed = 0;
                const others = state.players.filter(p => p.id !== player.id);
                
                if(others.length === 0) afterEffect();

                others.forEach((p) => {
                    flyValueToScore(centerRect, p.id, 10, () => {
                        changeScore(p, 10, true);
                        completed++;
                        if(completed === others.length) afterEffect();
                    });
                });

                log = "Diƒüerlerine +10!";
                state.lastUndoOp = () => { state.players.forEach(p => { if(p.id !== player.id) changeScore(p, -10); }); };
            }
            else if (card.type === CONSTANTS.CARD_TYPES.GLOBAL_MINUS) {
                AudioEngine.playActionBad('GLOBAL_MINUS');
                VFX.shakeScreen();
                VFX.flash('red');
                
                const centerRect = el.deck.getBoundingClientRect();
                let completed = 0;
                const others = state.players.filter(p => p.id !== player.id);

                if(others.length === 0) afterEffect();

                others.forEach((p) => {
                     flyValueToScore(centerRect, p.id, -10, () => {
                        changeScore(p, -10, true);
                        completed++;
                        if(completed === others.length) afterEffect();
                    });
                });

                log = "Diƒüerlerine -10!";
                state.lastUndoOp = () => { state.players.forEach(p => { if(p.id !== player.id) changeScore(p, 10); }); };
            }
            else if (card.type === CONSTANTS.CARD_TYPES.ACTION) {
                const key = card.meta.actionKey;
                if (key === 'THIEF') {
                    AudioEngine.playActionBad('THIEF');
                    const others = state.players.filter(p => p.id !== player.id);
                    if (others.length > 0) {
                        others.sort((a,b) => b.score - a.score);
                        const victim = others[0];
                        const stolen = Math.min(victim.score, 5);
                        
                        // Animate: Victim loses -> Attacker Gains
                        const victimCard = document.getElementById(`player-card-${victim.id}`);
                        const victimRect = victimCard ? victimCard.getBoundingClientRect() : visualRect;

                        flyValueToScore(victimRect, victim.id, -stolen, () => {
                            changeScore(victim, -stolen, true);
                            
                            setTimeout(() => {
                                flyValueToScore(victimRect, player.id, stolen, () => {
                                    changeScore(player, stolen); // Last one triggers render
                                    afterEffect();
                                });
                            }, 300);
                        });

                        log = `${victim.name}'den ${stolen} √áaldƒ±!`;
                        state.lastUndoOp = () => { changeScore(victim, stolen, true); changeScore(player, -stolen, false); };
                    } else { 
                        state.lastUndoOp = () => {}; 
                        afterEffect();
                    }
                } else if (key === 'BANKRUPT') {
                    AudioEngine.playActionBad('BANKRUPT');
                    VFX.shakeScreen();
                    VFX.flash('white');
                    const lost = Math.ceil(player.score / 2);
                    
                    flyValueToScore(visualRect, player.id, -lost, () => {
                        changeScore(player, -lost);
                        afterEffect();
                    });

                    log = "Puan Yarƒ±ya ƒ∞ndi!";
                    state.lastUndoOp = () => { changeScore(player, lost); };
                } else if (key === 'BOOM') {
                    AudioEngine.playActionBad('BOOM');
                    VFX.shakeScreen();
                    VFX.flash('red');
                    log = "BUM! Sƒ±ra Kaydƒ±!";
                    state.lastUndoOp = () => {};
                    afterEffect();
                }
            }
            player.lastAction = log;
        }

        function useJoker(playerId, type) {
            if (state.turnPhase !== CONSTANTS.TURN_PHASES.POST_DRAW || state.isGameOver) return;
            if (state.players[state.currentPlayerIdx].id !== playerId) return;

            const player = state.players.find(p => p.id === playerId);
            if (player.jokers[type]) return;
            
            const pCard = document.getElementById(`player-card-${player.id}`);
            const pRect = pCard.getBoundingClientRect();

            AudioEngine.playAlarm();
            VFX.flash('gold');

            player.jokers[type] = true;

            if (type === 'drain') {
                // Everyone else -10
                const others = state.players.filter(p => p.id !== playerId);
                others.forEach(p => {
                    flyValueToScore(pRect, p.id, -10, () => changeScore(p, -10));
                });
                
                player.lastAction = "‚ö†Ô∏è RAKƒ∞PLER -10!";
                showToast(`${player.name} rakipleri yaktƒ±!`);
                renderBoard(); // Update UI for joker buttons immediately
            }
            else if (type === 'double') {
                player.buffs.doubleDuration = 3;
                AudioEngine.playPowerUp();
                player.lastAction = "‚ö° 3 Tur 2x Aktif!";
                showToast("Sonraki √ßekili≈ülerin 2 katƒ± olacak!");
                renderBoard();
            }
            else if (type === 'pass') {
                if (state.lastUndoOp) state.lastUndoOp();

                // Score penalty animation
                flyValueToScore(pRect, player.id, -20, () => {
                    changeScore(player, -20);
                });

                player.lastAction = "‚û°Ô∏è PASLANDI (-20)";

                const nextIdx = (state.currentPlayerIdx + 1) % state.players.length;
                const nextPlayer = state.players[nextIdx];
                
                showToast(`Kart ${nextPlayer.name}'e kilitlendi!`);
                animatePass(player.id, nextPlayer.id);

                state.currentPlayerIdx = nextIdx;
                // Re-apply card effect to new player, use old visual pos
                const deckRect = el.deck.getBoundingClientRect();
                applyCardEffect(state.lastDrawnCard, nextPlayer, deckRect);
                // No renderBoard needed here as applyCardEffect handles it via afterEffect or manual
            }
        }

        function animatePass(fromId, toId) {
            const fromCard = document.getElementById(`player-card-${fromId}`);
            const toCard = document.getElementById(`player-card-${toId}`);
            if(fromCard && toCard) {
                const dummy = document.createElement('div');
                dummy.innerHTML = "‚û°Ô∏è";
                dummy.style.position = 'fixed';
                dummy.style.fontSize = '3rem';
                dummy.style.zIndex = 999;
                dummy.style.transition = 'all 0.5s ease';
                const r1 = fromCard.getBoundingClientRect();
                const r2 = toCard.getBoundingClientRect();
                dummy.style.left = (r1.left + r1.width/2) + 'px';
                dummy.style.top = (r1.top + r1.height/2) + 'px';
                document.body.appendChild(dummy);
                setTimeout(() => {
                    dummy.style.left = (r2.left + r2.width/2) + 'px';
                    dummy.style.top = (r2.top + r2.height/2) + 'px';
                }, 50);
                setTimeout(() => dummy.remove(), 600);
            }
        }

        function manualEndTurn() {
            if (state.turnPhase !== CONSTANTS.TURN_PHASES.POST_DRAW) return;
            const isBoom = state.lastDrawnCard && 
                           state.lastDrawnCard.type === CONSTANTS.CARD_TYPES.ACTION && 
                           state.lastDrawnCard.meta.actionKey === 'BOOM';
            nextTurn(isBoom);
        }

        function nextTurn(isBoomEffect = false) {
            if (state.deck.length === 0) { endGame(); return; }

            state.currentPlayerIdx = (state.currentPlayerIdx + 1) % state.players.length;
            state.drawsLeft = 1;
            state.turnPhase = CONSTANTS.TURN_PHASES.WAITING_DRAW;
            state.lastDrawnCard = null;
            state.lastUndoOp = null;
            state.hasUsedRiskCard = false;
            state.hasUsedDuelCard = false; // Sƒ±ra deƒüi≈üti, haklar bu tur i√ßin yenilendi

            renderBoard();
            updateDeckUI();

            const nextPlayer = state.players[state.currentPlayerIdx];
            if (isBoomEffect) {
                if (state.deck.length === 0) {
                     endGame();
                     return;
                }
                state.isProcessing = true; 
                showToast(`BUM! ${nextPlayer.name} ZORLA √áEKƒ∞YOR!`);
                setTimeout(() => { drawCardLogic(true); }, 1000);
            } else {
                showToast(`Sƒ±ra: ${nextPlayer.name}`);
            }
        }

        function endGame() {
            if (state.isGameOver) return; 
            state.isGameOver = true;
            
            AudioEngine.playWin();
            const sortedPlayers = [...state.players].sort((a, b) => b.score - a.score);
            
            el.game.classList.add('hidden');
            el.pause.classList.add('hidden');
            el.end.classList.remove('hidden');
            el.winnerText.innerText = `KAZANAN: ${sortedPlayers[0].name}`;
            el.winnerText.style.color = sortedPlayers[0].color;
            
            let html = '';
            sortedPlayers.forEach((p, idx) => {
                html += `
                    <div class="score-row">
                        <div><span class="rank-badge">${idx + 1}</span>${p.name}</div>
                        <div style="font-weight:bold; color: ${p.color}">${p.score}</div>
                    </div>
                `;
            });
            el.scoreboard.innerHTML = html;
            startConfetti();
        }

        function returnToLobby() {
            stopConfetti();
            state.players = [];
            state.deck = [];
            state.attackDeck = [];
            state.duelDeck = [];
            state.isGameOver = false;
            state.isProcessing = false;
            state.isPaused = false; 
            
            el.end.classList.add('hidden');
            el.pause.classList.add('hidden');
            el.game.classList.add('hidden');
            el.targetModal.classList.add('hidden');
            el.duelModal.classList.add('hidden');
            el.rulesModal.classList.add('hidden');
            el.lobby.classList.remove('hidden');
        }

        function renderBoard() {
            el.playersTop.innerHTML = '';
            el.playersBottom.innerHTML = '';
            const mid = Math.ceil(state.players.length / 2);

            // Check for 4-player mode for corner layout
            if (state.players.length === 4) {
                el.playersTop.classList.add('mode-4p');
                el.playersBottom.classList.add('mode-4p');
            } else {
                el.playersTop.classList.remove('mode-4p');
                el.playersBottom.classList.remove('mode-4p');
            }

            const isMyTurn = !state.isGameOver && !state.isPaused;
            const currentPlayer = state.players[state.currentPlayerIdx];
            
            // ANA DESTE
            const shouldDraw = state.turnPhase === CONSTANTS.TURN_PHASES.WAITING_DRAW && !state.isProcessing && isMyTurn;
            
            // Reset classes
            el.deck.className = 'deck-wrapper deck-main';
            el.attackDeck.className = 'deck-wrapper deck-attack';
            el.duelDeck.className = 'deck-wrapper deck-duel';

            // MAIN DECK STATE
            if (state.turnPhase === CONSTANTS.TURN_PHASES.POST_DRAW && !state.isGameOver) {
                el.btnNextTurn.classList.remove('hidden');
                el.deck.classList.add('disabled');
            } else {
                el.btnNextTurn.classList.add('hidden');
                if (shouldDraw) el.deck.classList.add('deck-active');
                else if (state.isProcessing) el.deck.classList.add('used'); // Busy visual
            }

            // RISK DESTESƒ∞ STATE
            const isRiskDisabled = !isMyTurn || (currentPlayer && currentPlayer.riskRights <= 0) || state.attackDeck.length === 0;
            const canUseRisk = !isRiskDisabled && !state.hasUsedRiskCard && !state.isProcessing;

            if (isRiskDisabled) {
                el.attackDeck.classList.add('disabled');
            } else if (state.hasUsedRiskCard) {
                el.attackDeck.classList.add('used');
            } else if (state.isProcessing) {
                el.attackDeck.classList.add('used'); // Show as busy/dimmed but not disabled
            } else {
                el.attackDeck.classList.add('deck-active');
            }

            // DUEL DESTESƒ∞ STATE
            const isDuelDisabled = !isMyTurn || (currentPlayer && currentPlayer.duelRights <= 0) || state.duelDeck.length === 0;
            const canUseDuel = !isDuelDisabled && !state.hasUsedDuelCard && !state.isProcessing;

            if (isDuelDisabled) {
                el.duelDeck.classList.add('disabled');
            } else if (state.hasUsedDuelCard) {
                el.duelDeck.classList.add('used');
            } else if (state.isProcessing) {
                el.duelDeck.classList.add('used'); // Show as busy
            } else {
                el.duelDeck.classList.add('deck-active');
            }

            state.players.forEach((p, i) => {
                const isActive = (i === state.currentPlayerIdx);
                const isBuffed = (p.buffs.doubleDuration > 0);
                
                const div = document.createElement('div');
                div.className = `player-card ${isActive ? 'active' : ''} ${isBuffed ? 'double-buff' : ''}`;
                div.id = `player-card-${p.id}`;
                div.style = `--player-color: ${p.color}`; 
                
                div.style.borderColor = p.color;
                if (isActive) {
                    // Insert glowing border element
                    const glow = document.createElement('div');
                    glow.className = 'active-border-glow';
                    div.appendChild(glow);
                } else {
                    div.style.boxShadow = '0 4px 8px rgba(0,0,0,0.5)';
                    div.style.borderColor = adjustColorOpacity(p.color, 0.5);
                }

                const canUseJoker = isActive && state.turnPhase === CONSTANTS.TURN_PHASES.POST_DRAW && !state.isGameOver;
                const btnPassDisabled = !canUseJoker || p.jokers.pass ? 'disabled' : '';
                const btnDrainDisabled = !canUseJoker || p.jokers.drain ? 'disabled' : '';
                const btnDoubleDisabled = !canUseJoker || p.jokers.double ? 'disabled' : '';

                const buffText = isBuffed ? `‚ö° 2x (${p.buffs.doubleDuration})` : '';

                div.innerHTML += `
                    <div class="player-name">${p.name}</div>
                    <div class="player-stats-row">
                         <span style="color:#ff3333; font-weight:bold;">üí£ ${p.riskRights}</span>
                         <span class="stat-duel">‚ö° ${p.duelRights}</span>
                    </div>
                    <div class="player-score" id="score-${p.id}" style="color:${p.color}">${p.score}</div>
                    <div class="player-buff-indicator" style="font-size:0.7rem; text-align:center;">${buffText}</div>
                    <div class="last-action">${p.lastAction}</div>
                    <div class="joker-container">
                        <button class="joker-btn joker-pass" ${btnPassDisabled} onclick="useJoker(${p.id}, 'pass')">
                            ‚û°Ô∏è
                            <span class="joker-tooltip">Pasla (-20)</span>
                        </button>
                        <button class="joker-btn joker-drain" ${btnDrainDisabled} onclick="useJoker(${p.id}, 'drain')">
                            üîª
                            <span class="joker-tooltip">Rakipler -10</span>
                        </button>
                        <button class="joker-btn joker-double" ${btnDoubleDisabled} onclick="useJoker(${p.id}, 'double')">
                            ‚ö°
                            <span class="joker-tooltip">3 Tur 2x</span>
                        </button>
                    </div>
                `;

                if (i < mid) el.playersTop.appendChild(div);
                else el.playersBottom.appendChild(div);
            });
        }

        function adjustColorOpacity(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function updateDeckUI() {
            el.deckCount.innerText = `HAMLE (${state.deck.length})`;
            if (state.deck.length === 0) el.deck.style.opacity = '0.3';

            el.attackDeckCount.innerText = `RISK (${state.attackDeck.length})`;
            if (state.attackDeck.length === 0) el.attackDeck.style.opacity = '0.3';
            
            el.duelDeckCount.innerText = `SALDIRI (${state.duelDeck.length})`;
            if (state.duelDeck.length === 0) el.duelDeck.style.opacity = '0.3';
        }

        function animateDraw(cardData, targetPlayerIndex, callback) {
            const flyer = document.createElement('div');
            let typeClass = 'type-number';
            if (cardData.type === CONSTANTS.CARD_TYPES.COMBO) typeClass = 'type-combo';
            if (cardData.type === CONSTANTS.CARD_TYPES.ACTION) typeClass = 'type-action';
            if (cardData.type === CONSTANTS.CARD_TYPES.GLOBAL_PLUS) typeClass = 'card-global-plus';
            if (cardData.type === CONSTANTS.CARD_TYPES.GLOBAL_MINUS) typeClass = 'card-global-minus';
            
            flyer.className = `flying-card ${typeClass}`;
            flyer.innerHTML = `
                <div class="card-content-icon">${cardData.meta.icon}</div>
                <div class="card-content-text">${cardData.meta.label}</div>
                ${cardData.meta.desc ? `<div class="card-content-desc">${cardData.meta.desc}</div>` : ''}
            `;
            document.body.appendChild(flyer);

            const deckRect = el.deck.getBoundingClientRect();
            flyer.style.left = (deckRect.left) + 'px';
            flyer.style.top = (deckRect.top) + 'px';
            flyer.style.transform = 'scale(0.5)';

            const targetP = state.players[targetPlayerIndex];
            const pCard = document.getElementById(`player-card-${targetP.id}`);
            let finalRect = deckRect; // Default to deck if player card missing

            requestAnimationFrame(() => {
                if (pCard) {
                    const pRect = pCard.getBoundingClientRect();
                    // Center of card logic
                    // Kart boyutu class tarafƒ±ndan belirlenir, JS ile sabitlemeye gerek yok,
                    // ancak hedefi ortalamak i√ßin kartƒ±n geni≈üliƒüini/y√ºksekliƒüini bilmemiz lazƒ±m.
                    // CSS'ten deƒüer okuyamayacaƒüƒ±mƒ±z i√ßin yakla≈üƒ±k bir offset kullanƒ±yoruz.
                    // Mobile i√ßin offseti dinamik yapalƒ±m.
                    
                    const isMobile = window.innerWidth <= 768;
                    const cardW = isMobile ? 90 : 130;
                    const cardH = isMobile ? 120 : 180;

                    const targetX = pRect.left + (pRect.width / 2) - (cardW / 2); 
                    const targetY = pRect.top + (pRect.height / 2) - (cardH / 2); 
                    
                    flyer.style.left = targetX + 'px';
                    flyer.style.top = targetY + 'px';
                    flyer.style.transform = 'scale(1)';
                    
                    // Store rect for next animation step
                    finalRect = flyer.getBoundingClientRect();
                }
            });

            setTimeout(() => {
                // Capture the position right before fading out for the value projectile
                const currentRect = flyer.getBoundingClientRect();
                
                flyer.style.opacity = '0';
                setTimeout(() => {
                    flyer.remove();
                    if (callback) callback(currentRect);
                }, 300);
            }, 800); 
        }

        function showToast(msg) {
            el.toast.innerText = msg;
            el.toast.style.opacity = '1';
            el.toast.style.transform = 'translateX(-50%) translateY(0)';
            setTimeout(() => {
                el.toast.style.opacity = '0';
                el.toast.style.transform = 'translateX(-50%) translateY(20px)';
            }, 2000);
        }

        /* --- KONFETƒ∞ --- */
        let confettiReq;
        const canvas = document.getElementById("confetti-canvas");
        const ctx = canvas.getContext("2d");
        let particles = [];

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function startConfetti() {
            particles = [];
            for(let i=0; i<150; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height - canvas.height,
                    color: `hsl(${Math.random() * 360}, 100%, 50%)`,
                    size: Math.random() * 8 + 4,
                    speedY: Math.random() * 3 + 2,
                    speedX: Math.random() * 4 - 2,
                    rotation: Math.random() * 360,
                    rotationSpeed: Math.random() * 10 - 5
                });
            }
            loopConfetti();
        }

        function loopConfetti() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach(p => {
                p.y += p.speedY;
                p.x += p.speedX;
                p.rotation += p.rotationSpeed;
                if (p.y > canvas.height) p.y = -20;
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.rotation * Math.PI / 180);
                ctx.fillStyle = p.color;
                ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                ctx.restore();
            });
            confettiReq = requestAnimationFrame(loopConfetti);
        }

        function stopConfetti() {
            if (confettiReq) {
                cancelAnimationFrame(confettiReq);
                confettiReq = null;
            }
            if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    </script>
</body>
</html>
